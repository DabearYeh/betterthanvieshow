# ✅ 釐清決議：訂票 - 付款失敗時如何處理訂單與票券

**決議日期**：2025-12-11  
**決議狀態**：✅ 已完成  
**優先級**：High ⭐

---

## 📌 決議內容

### 核心規則
**付款失敗後：訂單保持未付款狀態，座位繼續鎖定，用戶可重新嘗試，3 分鐘後自動取消**

### 完整流程

#### 1. 支付失敗的各種情況

```
支付過程的失敗類型：

1️⃣ 用戶主動中斷
   └─ 點擊「返回」或關閉支付頁面
   
2️⃣ 支付商拒絕
   └─ 銀行返回「餘額不足」、「卡片被拒」等
   
3️⃣ 網路中斷
   └─ 支付請求超時、連線失敗
   
4️⃣ 系統異常
   └─ 支付 API 異常、資料庫錯誤

所有情況的處理邏輯相同 ↓
```

#### 2. 支付失敗後的狀態

```
支付前：
  Order.status = 'awaiting_payment'
  Ticket.status = 'awaiting_payment'
  Seat 被鎖定
  Order.expires_at = 建立時間 + 3 分鐘

支付失敗：
  ├─ Order.status = 'awaiting_payment'（不變）
  ├─ Ticket.status = 'awaiting_payment'（不變）
  ├─ Seat 被鎖定（不變，防止他人搶購）
  └─ Order.expires_at = 不變（倒計時繼續）

用戶可以：
  ├─ ✅ 重新嘗試支付（進入支付頁面）
  ├─ ✅ 修改支付方式
  ├─ ✅ 取消訂單
  └─ ❌ 無法修改座位（座位被鎖定）

如果 3 分鐘內未付款：
  └─ 系統自動取消（同 Item 4）
```

#### 3. 支付失敗流程圖

```
用戶進入支付頁面
       ↓
  點擊「確認支付」
       ↓
  發送支付請求到支付商
       ↓
  ┌─ 支付成功 ────→ Order.status = 'paid' → 生成 QR Code
  │
  └─ 支付失敗 ────→ 返回錯誤信息
       ↓
  系統檢查 Order.status（仍為 awaiting_payment）
       ↓
  前端顯示「支付失敗」信息：
       ├─ 原因（卡片被拒、餘額不足等）
       └─ 「重試」、「修改支付方式」、「取消」按鈕
       ↓
  用戶選擇：
       ├─ 重試 → 重新發送支付請求
       ├─ 修改支付方式 → 返回支付方式選擇
       └─ 取消 → 取消訂單（座位釋放）
       ↓
  （如用戶無操作，3 分鐘後自動取消）
```

#### 4. 支付失敗的錯誤訊息分類

```
根據支付商返回的錯誤碼分類顯示：

餘額不足：
  └─ 「您的銀行餘額不足，請檢查帳戶或更換支付方式」

卡片被拒：
  └─ 「此卡片被拒，請聯絡發卡銀行或使用其他卡片」

網路錯誤：
  └─ 「網路連線失敗，請檢查網路設定後重試」

支付商異常：
  └─ 「支付服務暫時無法使用，請稍後再試」

超時：
  └─ 「支付請求超時，請重新嘗試」

未知錯誤：
  └─ 「支付失敗，請重新嘗試或聯絡客服」
```

#### 5. 重新嘗試支付

```
用戶點擊「重試」：
  ├─ 驗證 Order.status 仍為 'awaiting_payment'
  ├─ 驗證 Order 未過期（expired_at > 現在時間）
  ├─ 驗證所有 Ticket 仍為 'awaiting_payment'
  ├─ 驗證座位仍被該訂單鎖定
  └─ 允許重新進入支付流程

如果 Order 已過期或被取消：
  └─ 返回錯誤：「訂單已過期，請重新訂票」
```

#### 6. 支付失敗後用戶可能的操作

```
選項 1：重新支付
  └─ 保持同一訂單，嘗試不同支付方式或帳戶
  
選項 2：修改訂單
  └─ ❌ 不支持（訂單已建立，座位已鎖定）
  └─ 用戶需先取消再重新訂票
  
選項 3：取消訂單
  └─ 立即釋放座位，不等 3 分鐘倒計時
  
選項 4：等待超時
  └─ 無操作，3 分鐘後自動取消
```

---

## 🔧 實施影響

#### 1. **支付 API 實施** ✅

```javascript
// 支付請求
async function processPayment(req, res) {
  const { order_id, payment_method, payment_details } = req.body;
  
  try {
    // 1. 查詢訂單
    const order = await Order.findById(order_id);
    
    if (!order) {
      return res.status(404).json({ error: '訂單不存在' });
    }
    
    // 2. 驗證訂單狀態
    if (order.status !== 'awaiting_payment') {
      return res.status(400).json({ 
        error: '訂單狀態不允許支付',
        current_status: order.status 
      });
    }
    
    // 3. 驗證未過期
    if (new Date() > order.expires_at) {
      return res.status(400).json({ 
        error: '訂單已過期' 
      });
    }
    
    // 4. 驗證座位仍被鎖定
    const tickets = await Ticket.findAll({ 
      where: { order_id: order_id }
    });
    
    for (const ticket of tickets) {
      const seat = await Seat.findById(ticket.seat_id);
      // 檢查座位是否被該訂單鎖定
      // 邏輯取決於應用的座位鎖定實現
    }
    
    // 5. 調用支付商 API
    let paymentResult;
    try {
      paymentResult = await callPaymentProvider({
        order_number: order.order_number,
        amount: order.total_price,
        method: payment_method,
        details: payment_details
      });
    } catch (paymentError) {
      // 支付商返回錯誤
      console.error('支付失敗:', paymentError);
      
      return res.status(400).json({
        success: false,
        error: mapPaymentErrorMessage(paymentError),
        error_code: paymentError.code,
        // ❌ Order 狀態不變，保持 awaiting_payment
        // 座位繼續鎖定
        // 用戶可重試
        retry_available: true,
        time_remaining_seconds: Math.ceil(
          (order.expires_at - new Date()) / 1000
        )
      });
    }
    
    // 6. 支付成功
    if (paymentResult.success) {
      await sequelize.transaction(async (t) => {
        // 更新訂單為已付款
        await order.update(
          { status: 'paid' },
          { transaction: t }
        );
        
        // 生成票券 QR Code
        for (const ticket of tickets) {
          const qrCode = generateQRCode({
            ticket_id: ticket.id,
            order_number: order.order_number,
            seat: `${ticket.seat.row_name}${ticket.seat.column_number}`,
            show_time: order.showTime.show_date + ' ' + order.showTime.start_time
          });
          
          await ticket.update(
            { qr_code: qrCode },
            { transaction: t }
          );
        }
        
        // 記錄支付日誌
        await PaymentLog.create({
          order_id: order_id,
          amount: order.total_price,
          payment_method: payment_method,
          provider_response: paymentResult,
          status: 'success',
          paid_at: new Date()
        }, { transaction: t });
      });
      
      return res.json({
        success: true,
        message: '支付成功',
        order_number: order.order_number,
        redirect_url: `/ticket/${order_id}`
      });
    }
    
  } catch (error) {
    // 系統異常（非支付商）
    console.error('支付系統異常:', error);
    
    return res.status(500).json({
      success: false,
      error: '支付系統異常，請稍後重試',
      retry_available: true
    });
  }
}

// 對應支付商錯誤碼至用戶友善訊息
function mapPaymentErrorMessage(error) {
  const errorMap = {
    'INSUFFICIENT_FUNDS': '您的銀行餘額不足',
    'CARD_DECLINED': '此卡片被拒，請聯絡銀行',
    'INVALID_CARD': '卡片資訊不正確',
    'NETWORK_ERROR': '網路連線失敗',
    'TIMEOUT': '支付請求超時',
    'PROVIDER_ERROR': '支付服務暫時無法使用'
  };
  
  return errorMap[error.code] || '支付失敗，請重新嘗試';
}

// 重新嘗試支付
async function retryPayment(req, res) {
  const { order_id } = req.params;
  
  // 驗證訂單是否仍可支付（同上）
  const order = await Order.findById(order_id);
  
  if (order.status !== 'awaiting_payment') {
    return res.status(400).json({ error: '訂單無法重新支付' });
  }
  
  if (new Date() > order.expires_at) {
    return res.status(400).json({ error: '訂單已過期' });
  }
  
  // 返回支付頁面 URL
  return res.json({
    success: true,
    payment_url: `/payment/${order_id}`
  });
}
```

#### 2. **前端實施** ✅

```javascript
// 支付頁面
async function submitPayment(orderId, paymentMethod) {
  try {
    const response = await fetch('/api/payments', {
      method: 'POST',
      body: JSON.stringify({
        order_id: orderId,
        payment_method: paymentMethod,
        payment_details: { /* 卡片資訊等 */ }
      })
    });
    
    const result = await response.json();
    
    if (result.success) {
      // 支付成功
      alert('支付成功！');
      window.location.href = result.redirect_url;
    } else {
      // 支付失敗
      displayPaymentError({
        error: result.error,
        retry_available: result.retry_available,
        time_remaining: result.time_remaining_seconds
      });
    }
    
  } catch (error) {
    displayPaymentError({
      error: '支付請求失敗',
      retry_available: true
    });
  }
}

// 顯示支付失敗信息
function displayPaymentError(errorInfo) {
  const errorDiv = document.getElementById('error-message');
  
  let html = `
    <div class="alert alert-danger">
      <strong>支付失敗</strong>
      <p>${errorInfo.error}</p>
  `;
  
  if (errorInfo.retry_available) {
    const minutes = Math.ceil(errorInfo.time_remaining / 60);
    html += `
      <p class="text-muted">
        請在 ${minutes} 分鐘內完成支付，否則訂單將自動取消
      </p>
      <button onclick="location.reload()" class="btn btn-primary">重新嘗試</button>
      <button onclick="cancelOrder()" class="btn btn-secondary">取消訂單</button>
    `;
  } else {
    html += `
      <p class="text-danger">訂單已過期或無法支付，請重新訂票</p>
      <button onclick="window.location.href='/'" class="btn btn-primary">返回首頁</button>
    `;
  }
  
  html += '</div>';
  errorDiv.innerHTML = html;
}
```

---

## 🎯 設計理由

### 1. 寬容機制
- 支付失敗不刪除訂單，用戶可重試
- 座位保留 3 分鐘，確保用戶有時間重試

### 2. 自動清理
- 3 分鐘後自動取消，無需手動干預
- 防止僵屍訂單占用座位

### 3. 信息清晰
- 錯誤訊息分類，用戶知道原因
- 提示剩餘時間，促進快速行動

### 4. 安全驗證
- 每次支付前重新驗證訂單狀態和座位鎖定
- 防止過期訂單或錯誤訂單被支付

---

## ✅ 檢查清單

- [x] 決議文字版本創建
- [ ] 支付 API 邏輯實施（下一步）
- [ ] 錯誤訊息對應（下一步）
- [ ] 前端重試邏輯（下一步）

---

**Phase 2 完成狀態**：✅ Item 1-5/8 完成

**下一個釐清項目**：`瀏覽電影_正在上映與即將上映的判斷邏輯為何.md`

---

**文檔版本**：v1.0  
**最後更新**：2025-12-11  
**維護人員**：GitHub Copilot
